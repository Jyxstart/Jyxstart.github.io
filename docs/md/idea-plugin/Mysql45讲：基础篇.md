## 01 | 基础架构: 一条SQL查询语句是如何执行的？

<img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img" style="zoom: 33%;" />

Mysql可以分为Server层和存储引擎两部分。

1. Server层包括连接器(建立连接、获取权限、维持和管理连接)、查询缓存(建议不用8.0版本已删除)、分析器(词法分析和语法分析)、优化器(决定使用哪个索引、各个表连接顺序)、执行器等，涵盖大部分Mysql核心功能，以及所有内置函数，还有存储过程、视图、触发器等等。

2. 存储引擎负责数据的存储和存取。支持InnoDB、MyISAM、Memory等多个存储引擎，从Mysql5.5.5默认存储引擎为InnoDB。

   

## 02 | 日志系统:一条SQL更新语句是如何执行的？

1. redo log(存储引擎 InnoDB特有 循环写 crash-safe(当数据库宕机时重启后数据不会丢失))

   InnoDB的redo log为固定大小， 它读写文件为磁盘顺序读写。

   write pos:当前位置。

   check point:当前要擦除的位置，擦除前要把记录更新到数据文件。

   write pos与check point之间为剩余空间，当不够时check point会向前推进。

   <img src="https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png" alt="img" style="zoom: 50%;" />

2. bin log(Server层 追加写 主要用于归档)

   bin log文件写满时不会清除之前的数据。
   
   

## 03 | 事物隔离:为什么你改了我还看不见？

事物：A(原子性)C(一致性)I(隔离性)D(持久性)

|          | 脏读  | 不可重复读 | 幻读  |
| :------: | :---: | :--------: | :---: |
| 读未提交 | **×** |   **×**    | **×** |
|  读提交  | **√** |   **×**    | **×** |
| 可重复读 | **√** |   **√**    | **×** |
|  串行化  | **√** |   **√**    | **√** |

脏读:一个事物读取到了另一个事物已经修改但未提交的数据。

不可重复读:一个事物第一次读到的数据与之后读取的数据不一致。(数据的修改)

幻读:一个事物读取到了另一个事物新增的数据。(数据的新增)



## 04 | 深入浅出索引（上）

### 索引的常见模型

- 哈希表
- 有序数组
- 搜索树

InnoDB的索引模型(B+tree)

### 索引类型

| 主键索引(聚簇索引)             | 非主键索引(二级索引)                                        |
| ------------------------------ | ----------------------------------------------------------- |
| 非叶子节点存储的是记录         | 非叶子节点存储的是主键ID                                    |
| 直接遍历非叶子节点就能得到结果 | 需要先获取主键ID后进行回表                                  |
|                                | **注意**:二级索引会加上主键索引字段(联合主键索引会发生去重) |

### 索引维护

数据是以整页的形式存储在磁盘中的。

- 如果新增数据所在的数据页已经满的话，就会产生新的数据页，这个过程称为页分裂。（现在大部分主键ID都用自增主键避免发生这种情况）

- 如果删除数据的话会导致相邻数据页数据的整合，这个过程称为页合并。(逻辑删除来避免这个情况的发生)

  


## 05 | 深入浅出索引（下）

### 联合索引

建立多个列为索引

### 覆盖索引

可以减少回表次数，查询的值就在改索引上

###　最左匹配原则

###　索引下推(５.６后引入)

对包含索引的字段先进行判断减少回表次数。



## 06| 全局锁和表锁:给表加个字段怎么有这么多阻碍？

### 全局锁

对整个数据库实例加锁

典型使用场景:全库逻辑备份

### 表级锁

- 表锁
- 元数据锁(MDL) Mysql 5.5引入MDL当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更的

操作，加MDL写锁。 **注意:**在同一个事物中如果有DDL语句会在此之前进行一次隐形提交，保证DDL位于一个单独的事物当中。



## 07 |行锁功过:怎么减少锁对性能的影响

#### 行锁

在事物提交之后释放(把最可能造成锁冲突 影响并发度的锁往后放)

### 死锁和死锁检测

两种策略:1.直接进入等待，直到超时。2.发起死锁检测，发现死锁后主动回滚死锁链条中的某一个事物，使其他事物得以继续执行。



## 08 | 事务到底是隔离的还是不隔离的？

### 启动事务的方式

begin/start transaction：在它们执行第一个操作语句的时候开启事务(此时产生trx_id)，此时产生一致性视图。

start transaction with consistent snaoshott：立即开启事务并创建一致性视图。

每个事务都会有一个数组(用来保存活跃事务ID(未提交的事务))

![image-20220311093551462](C:\Users\jiangyuxiang\AppData\Roaming\Typora\typora-user-images\image-20220311093551462.png)

| 黄色区域 | 白色区域                           | 绿色区域   |
| -------- | ---------------------------------- | ---------- |
| 数据可见 | 1.事务ID落在活跃数组中(数据不可见) | 数据不可见 |
|          | 2.不在活跃数组中(数据可见)         |            |



当前读:更新数据都是先读后写的，而这个读只能读当前的值。

select是快照读(历史版本),update,insert,delete会更新版本号是当前读(当前版本)。

























































